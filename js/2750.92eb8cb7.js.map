{"version":3,"file":"js/2750.92eb8cb7.js","mappings":"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","sources":["webpack://frontend/./src/utils/iconMap.ts","webpack://frontend/./src/hooks/useMap.ts","webpack://frontend/./src/views/recommendedCourse/CreateCourse.vue?e9bc","webpack://frontend/./src/views/recommendedCourse/CreateCourse.vue","webpack://frontend/./src/views/recommendedCourse/CreateCourse.vue?f9ba"],"sourcesContent":["import course from '@/assets/icon/course.svg';\nimport end from '@/assets/icon/end.svg';\nimport location from '@/assets/icon/location.svg';\nimport now from '@/assets/icon/now.svg';\nimport start from '@/assets/icon/start.svg';\n\nexport type IGubunType = 'start' | 'end' | 'location' | 'course' | 'now';\nexport const iconMap = {\n  course,\n  location,\n  now,\n  start,\n  end,\n};\n","import { requestRoute } from '@/apis/courseFeature';\nimport { iconMap, IGubunType } from '@/utils/iconMap';\nimport { ISpotType } from '@/stores/recommendedCourse/type';\nimport { findNowLocation } from '@/utils/map';\n\nexport const useMap = (map: any) => {\n  let drawInfoArr: any[] = [];\n  let resultdrawArr: any[] = [];\n  let markers: any[] = [];\n\n  const Tmapv2 = (window as any).Tmapv2;\n\n  const adjustZoomLevelToFitRoute = (drawInfoArr: any[]) => {\n    if (drawInfoArr.length > 0) {\n      const bounds = new Tmapv2.LatLngBounds();\n\n      drawInfoArr.forEach((point: any) => {\n        bounds.extend(point);\n      });\n\n      map.value.fitBounds(bounds);\n    } else {\n      console.error('Zoom 조정할 경로 데이터가 부족합니다.');\n    }\n  };\n\n  const createPolylineSegment = (\n    segmentPath: any[],\n    color: string,\n    weight: number\n  ) => {\n    return new Tmapv2.Polyline({\n      path: segmentPath,\n      strokeColor: color,\n      strokeWeight: weight,\n      fillOpacity: 1.0,\n      map: map.value,\n      direction: true,\n      directionColor: 'white',\n    });\n  };\n\n  const clearRoute = () => {\n    if (resultdrawArr.length > 0) {\n      resultdrawArr.forEach((line) => {\n        if (line && typeof line.setVisible === 'function') {\n          line.setVisible(false);\n        }\n      });\n      resultdrawArr = [];\n    }\n  };\n\n  const clearMarkers = () => {\n    markers.forEach((marker) => marker.setMap(null));\n    markers = [];\n  };\n\n  const drawLine = (arrPoint: any[]) => {\n    const totalPoints = arrPoint.length;\n    const SEGMENT_WEIGHTS = 10;\n    const SEGMENT_COLORS = [\n      '#75FFA5',\n      '#22F779',\n      '#13D168',\n      '#07AB56',\n      '#008545',\n    ];\n\n    SEGMENT_COLORS.forEach((color, index) => {\n      const start = Math.floor(totalPoints * (index * 0.2));\n      const end = Math.floor(totalPoints * ((index + 1) * 0.2));\n\n      const segmentPath = arrPoint.slice(start, end + 1);\n      const polyline = createPolylineSegment(\n        segmentPath,\n        color,\n        SEGMENT_WEIGHTS\n      );\n\n      resultdrawArr.push(polyline);\n    });\n\n    adjustZoomLevelToFitRoute(arrPoint);\n  };\n\n  const requestLocationPermission = () => {\n    return new Promise((resolve, reject) => {\n      if (navigator.geolocation) {\n        navigator.geolocation.getCurrentPosition(\n          (position) => {\n            resolve(position);\n          },\n          (error) => {\n            if (error.code === error.PERMISSION_DENIED) {\n              alert(\n                '위치 권한이 거부되었습니다. 앱 설정에서 권한을 허용해 주세요.'\n              );\n              reject('위치 권한이 거부되었습니다.');\n            } else {\n              reject('위치를 가져오는 데 실패했습니다.');\n            }\n          }\n        );\n      } else {\n        reject('이 브라우저는 위치 서비스를 지원하지 않습니다.');\n      }\n    });\n  };\n\n  const initTmap = (map: any) => {\n    return new Promise<void>((resolve, reject) => {\n      if (!map.value) {\n        map.value = new Tmapv2.Map('map_div', {\n          width: '100%',\n          height: '100%',\n          zoom: 15,\n          scaleBar: false,\n          zoomControl: false,\n          httpsMode: true,\n        });\n        resolve();\n      } else {\n        reject('지도 객체 초기화 실패: 이미 초기화된 상태입니다.');\n      }\n    });\n  };\n\n  const removeMarker = (location: ISpotType) => {\n    const { latitude, longitude } = location;\n    if (!map.value || latitude === 0 || longitude === 0) return;\n\n    const markerIndex = markers.findIndex(\n      (marker) =>\n        marker.getPosition().lat() === latitude &&\n        marker.getPosition().lng() === longitude\n    );\n\n    if (markerIndex !== -1) {\n      markers[markerIndex].setMap(null);\n      markers.splice(markerIndex, 1);\n    } else {\n      console.log('해당 위치에 마커가 없습니다.');\n    }\n  };\n\n  const checkDuplMarker = (location: ISpotType): boolean => {\n    const { latitude, longitude } = location;\n    if (!latitude || !longitude || !map.value) return false;\n\n    return markers.some(\n      (marker) =>\n        marker.getPosition().lat() === latitude &&\n        marker.getPosition().lng() === longitude\n    );\n  };\n\n  const addMarker = (location: ISpotType, gubun: IGubunType) => {\n    const { latitude, longitude } = location;\n    if (!map.value || latitude === 0 || longitude === 0) return;\n\n    const markerPosition = new Tmapv2.LatLng(latitude, longitude);\n    const marker = new Tmapv2.Marker({\n      position: markerPosition,\n      icon: iconMap[gubun],\n      map: map.value,\n    });\n\n    markers.push(marker);\n    return marker;\n  };\n\n  const searchRoutes = async (\n    startLocation: ISpotType,\n    endLocation: ISpotType,\n    passList?: ISpotType[]\n  ) => {\n    try {\n      clearRoute();\n\n      const passListString = passList\n        ? passList\n            .map((point) => `${point.longitude},${point.latitude}`)\n            .join('_')\n        : '';\n\n      const resultData = await requestRoute(\n        String(startLocation.longitude),\n        String(startLocation.latitude),\n        String(endLocation.longitude),\n        String(endLocation.latitude),\n        passListString\n      );\n\n      drawInfoArr = [];\n\n      resultData.forEach((data: any) => {\n        const geometry = data.geometry;\n        const properties = data.properties;\n\n        if (geometry.type === 'LineString') {\n          geometry.coordinates.forEach((coord: any) => {\n            const latlng = new Tmapv2.Point(coord[0], coord[1]);\n            const convertPoint =\n              Tmapv2.Projection.convertEPSG3857ToWGS84GEO(latlng);\n            const convertChange = new Tmapv2.LatLng(\n              convertPoint._lat,\n              convertPoint._lng\n            );\n            drawInfoArr.push(convertChange);\n          });\n        }\n      });\n\n      drawLine(drawInfoArr);\n    } catch (error) {\n      console.error('경로 검색 중 오류 발생:', error);\n    }\n  };\n\n  const searchRoutesTest = async (map: any) => {\n    const startLocation: [number, number] = [\n      33.433944015499456, 126.43602130714433,\n    ];\n    const endLocation: [number, number] = [\n      33.45120886113757, 126.48765563964844,\n    ];\n    const passList =\n      '126.39573248492509,33.47190207955216_126.44226001173622,33.47486469122896_126.42766879469521,33.48001928930712';\n\n    try {\n      const resultData = await requestRoute(\n        String(startLocation[1]),\n        String(startLocation[0]),\n        String(endLocation[1]),\n        String(endLocation[0]),\n        passList\n      );\n\n      if (resultdrawArr.length > 0) {\n        resultdrawArr.forEach((line) => line.setMap(null));\n        resultdrawArr = [];\n      }\n\n      drawInfoArr = [];\n\n      resultData.forEach((data: any) => {\n        const geometry = data.geometry;\n        const properties = data.properties;\n\n        if (geometry.type === 'LineString') {\n          geometry.coordinates.forEach((coord: any) => {\n            const latlng = new Tmapv2.Point(coord[0], coord[1]);\n            const convertPoint =\n              Tmapv2.Projection.convertEPSG3857ToWGS84GEO(latlng);\n            const convertChange = new Tmapv2.LatLng(\n              convertPoint._lat,\n              convertPoint._lng\n            );\n            drawInfoArr.push(convertChange);\n          });\n        } else if (\n          properties.pointType !== 'GP' &&\n          properties.pointType.includes('PP')\n        ) {\n          const latlon = new Tmapv2.Point(\n            geometry.coordinates[0],\n            geometry.coordinates[1]\n          );\n          const convertPoint =\n            Tmapv2.Projection.convertEPSG3857ToWGS84GEO(latlon);\n\n          new Tmapv2.Marker({\n            position: new Tmapv2.LatLng(convertPoint._lat, convertPoint._lng),\n            icon: iconMap['location'],\n            map: map.value,\n          });\n        }\n      });\n      drawLine(drawInfoArr);\n    } catch (error) {\n      console.error('경로 검색 중 오류 발생:', error);\n    }\n  };\n\n  const moveLocation = (latitude: number, longitude: number) => {\n    if (!map.value) return;\n\n    if (!isNaN(latitude) && !isNaN(longitude)) {\n      const currentLocation = new Tmapv2.LatLng(latitude, longitude);\n      map.value.setCenter(currentLocation);\n      map.value.setZoom(15);\n    } else {\n      console.error('유효하지 않은 좌표:', latitude, longitude);\n    }\n  };\n\n  const moveNowLocation = async () => {\n    try {\n      const position: any = await requestLocationPermission();\n      const { latitude, longitude } = position.coords;\n\n      const markerPosition = new Tmapv2.LatLng(latitude, longitude);\n      new Tmapv2.Marker({\n        position: markerPosition,\n        icon: iconMap['now'],\n        map: map.value,\n      });\n\n      moveLocation(latitude, longitude);\n    } catch (error) {\n      console.error(error);\n      alert('현재 위치를 가져오는 데 실패했습니다.');\n\n      const defaultLatitude = 33.50712081595116;\n      const defaultLongitude = 126.49340629577637;\n      moveLocation(defaultLatitude, defaultLongitude);\n    }\n  };\n\n  return {\n    initTmap,\n    removeMarker,\n    searchRoutes,\n    addMarker,\n    clearMarkers,\n    checkDuplMarker,\n    moveLocation,\n    moveNowLocation,\n    searchRoutesTest,\n  };\n};\n","import { defineComponent as _defineComponent } from 'vue'\nimport { unref as _unref, openBlock as _openBlock, createBlock as _createBlock, createCommentVNode as _createCommentVNode, createElementVNode as _createElementVNode, resolveDynamicComponent as _resolveDynamicComponent, withCtx as _withCtx, createVNode as _createVNode, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\"\n\nconst _withScopeId = (n: any) => (_pushScopeId(\"data-v-3024e6c6\"),n=n(),_popScopeId(),n)\nconst _hoisted_1 = { class: \"container\" }\nconst _hoisted_2 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(\"div\", { id: \"map_div\" }, null, -1))\n\nimport { ref, onMounted, defineComponent, watch } from 'vue';\r\nimport { useMap } from '@/hooks';\r\nimport { SwipeModal } from '@/components';\r\nimport {\r\n  SuggestionHelper,\r\n  ResultHelper,\r\n  WayPoint,\r\n  SelectKeyword,\r\n  CheckPublic,\r\n  CompleteCourse,\r\n  MapSearch,\r\n  SearchResult,\r\n  InputTitle,\r\n} from './components';\r\n\r\nimport { storeToRefs } from 'pinia';\r\nimport { useCreateCourseStore } from '@/stores/recommendedCourse/createCourse';\r\nimport { ISpotType } from '@/stores/recommendedCourse/type';\r\n\r\n\nexport default /*#__PURE__*/_defineComponent({\n  __name: 'CreateCourse',\n  setup(__props) {\n\r\nconst createCourseStore = useCreateCourseStore();\r\nconst {\r\n  page,\r\n  showSearch,\r\n  startPointValid,\r\n  endPointValid,\r\n  wayPointsValid,\r\n  wayPoint,\r\n  endPoint,\r\n  startPoint,\r\n} = storeToRefs(createCourseStore);\r\n\r\nconst map = ref<any>(null);\r\nconst {\r\n  initTmap,\r\n  addMarker,\r\n  searchRoutes,\r\n  removeMarker,\r\n  checkDuplMarker,\r\n  moveNowLocation,\r\n} = useMap(map);\r\n\r\nconst componentMap: { [key: number]: ReturnType<typeof defineComponent> } = {\r\n  1: WayPoint,\r\n  2: InputTitle,\r\n  3: SelectKeyword,\r\n  4: CheckPublic,\r\n  5: CompleteCourse,\r\n  11: SuggestionHelper,\r\n  12: ResultHelper,\r\n};\r\n\r\nonMounted(async () => {\r\n  await initTmap(map);\r\n  await moveNowLocation();\r\n});\r\n\r\nconst handleMarkerChange = (\r\n  newPoint: ISpotType,\r\n  oldPoint: ISpotType | undefined,\r\n  markerType: 'start' | 'end' | 'location'\r\n) => {\r\n  if (newPoint && startPointValid.value) {\r\n    const isDuplicate = checkDuplMarker(newPoint);\r\n\r\n    if (!isDuplicate) {\r\n      addMarker(newPoint, markerType);\r\n    }\r\n  }\r\n\r\n  if (\r\n    oldPoint &&\r\n    (newPoint.name !== oldPoint.name ||\r\n      newPoint.longitude !== oldPoint.longitude ||\r\n      newPoint.latitude !== oldPoint.latitude)\r\n  ) {\r\n    removeMarker(oldPoint);\r\n  }\r\n};\r\n\r\nconst handleSearchRoutes = () => {\r\n  if (startPointValid.value && endPointValid.value && wayPointsValid.value) {\r\n    searchRoutes(startPoint.value, endPoint.value, wayPoint.value);\r\n  }\r\n};\r\n\r\nwatch(\r\n  () => startPoint.value,\r\n  (newStartPoint, oldStartPoint) => {\r\n    handleMarkerChange(newStartPoint, oldStartPoint, 'start');\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => endPoint.value,\r\n  (newEndPoint, oldEndPoint) => {\r\n    handleMarkerChange(newEndPoint, oldEndPoint, 'end');\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => [...wayPoint.value],\r\n  (newWayPoints, oldWayPoints) => {\r\n    newWayPoints.forEach((newPoint, index) => {\r\n      const oldPoint = oldWayPoints[index];\r\n      handleMarkerChange(newPoint, oldPoint, 'location');\r\n    });\r\n\r\n    if (newWayPoints.length < oldWayPoints.length) {\r\n      for (let i = newWayPoints.length; i < oldWayPoints.length; i++) {\r\n        removeMarker(oldWayPoints[i]);\r\n      }\r\n    }\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => [wayPoint.value, startPoint.value, endPoint.value],\r\n  handleSearchRoutes,\r\n  { deep: true }\r\n);\r\n\nreturn (_ctx: any,_cache: any) => {\n  return (_openBlock(), _createElementBlock(\"div\", _hoisted_1, [\n    (_unref(showSearch))\n      ? (_openBlock(), _createBlock(_unref(MapSearch), { key: 0 }))\n      : _createCommentVNode(\"\", true),\n    _hoisted_2,\n    _createVNode(_unref(SwipeModal), null, {\n      default: _withCtx(() => [\n        (_unref(showSearch))\n          ? (_openBlock(), _createBlock(_unref(SearchResult), { key: 0 }))\n          : (componentMap[_unref(page)])\n            ? (_openBlock(), _createBlock(_resolveDynamicComponent(componentMap[_unref(page)]), { key: 1 }))\n            : _createCommentVNode(\"\", true)\n      ]),\n      _: 1\n    })\n  ]))\n}\n}\n\n})","<template>\r\n  <div class=\"container\">\r\n    <MapSearch v-if=\"showSearch\" />\r\n    <div id=\"map_div\"></div>\r\n    <SwipeModal>\r\n      <SearchResult v-if=\"showSearch\" />\r\n      <component\r\n        v-else-if=\"componentMap[page]\"\r\n        :is=\"componentMap[page]\"\r\n      />\r\n    </SwipeModal>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { ref, onMounted, defineComponent, watch } from 'vue';\r\nimport { useMap } from '@/hooks';\r\nimport { SwipeModal } from '@/components';\r\nimport {\r\n  SuggestionHelper,\r\n  ResultHelper,\r\n  WayPoint,\r\n  SelectKeyword,\r\n  CheckPublic,\r\n  CompleteCourse,\r\n  MapSearch,\r\n  SearchResult,\r\n  InputTitle,\r\n} from './components';\r\n\r\nimport { storeToRefs } from 'pinia';\r\nimport { useCreateCourseStore } from '@/stores/recommendedCourse/createCourse';\r\nimport { ISpotType } from '@/stores/recommendedCourse/type';\r\n\r\nconst createCourseStore = useCreateCourseStore();\r\nconst {\r\n  page,\r\n  showSearch,\r\n  startPointValid,\r\n  endPointValid,\r\n  wayPointsValid,\r\n  wayPoint,\r\n  endPoint,\r\n  startPoint,\r\n} = storeToRefs(createCourseStore);\r\n\r\nconst map = ref<any>(null);\r\nconst {\r\n  initTmap,\r\n  addMarker,\r\n  searchRoutes,\r\n  removeMarker,\r\n  checkDuplMarker,\r\n  moveNowLocation,\r\n} = useMap(map);\r\n\r\nconst componentMap: { [key: number]: ReturnType<typeof defineComponent> } = {\r\n  1: WayPoint,\r\n  2: InputTitle,\r\n  3: SelectKeyword,\r\n  4: CheckPublic,\r\n  5: CompleteCourse,\r\n  11: SuggestionHelper,\r\n  12: ResultHelper,\r\n};\r\n\r\nonMounted(async () => {\r\n  await initTmap(map);\r\n  await moveNowLocation();\r\n});\r\n\r\nconst handleMarkerChange = (\r\n  newPoint: ISpotType,\r\n  oldPoint: ISpotType | undefined,\r\n  markerType: 'start' | 'end' | 'location'\r\n) => {\r\n  if (newPoint && startPointValid.value) {\r\n    const isDuplicate = checkDuplMarker(newPoint);\r\n\r\n    if (!isDuplicate) {\r\n      addMarker(newPoint, markerType);\r\n    }\r\n  }\r\n\r\n  if (\r\n    oldPoint &&\r\n    (newPoint.name !== oldPoint.name ||\r\n      newPoint.longitude !== oldPoint.longitude ||\r\n      newPoint.latitude !== oldPoint.latitude)\r\n  ) {\r\n    removeMarker(oldPoint);\r\n  }\r\n};\r\n\r\nconst handleSearchRoutes = () => {\r\n  if (startPointValid.value && endPointValid.value && wayPointsValid.value) {\r\n    searchRoutes(startPoint.value, endPoint.value, wayPoint.value);\r\n  }\r\n};\r\n\r\nwatch(\r\n  () => startPoint.value,\r\n  (newStartPoint, oldStartPoint) => {\r\n    handleMarkerChange(newStartPoint, oldStartPoint, 'start');\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => endPoint.value,\r\n  (newEndPoint, oldEndPoint) => {\r\n    handleMarkerChange(newEndPoint, oldEndPoint, 'end');\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => [...wayPoint.value],\r\n  (newWayPoints, oldWayPoints) => {\r\n    newWayPoints.forEach((newPoint, index) => {\r\n      const oldPoint = oldWayPoints[index];\r\n      handleMarkerChange(newPoint, oldPoint, 'location');\r\n    });\r\n\r\n    if (newWayPoints.length < oldWayPoints.length) {\r\n      for (let i = newWayPoints.length; i < oldWayPoints.length; i++) {\r\n        removeMarker(oldWayPoints[i]);\r\n      }\r\n    }\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => [wayPoint.value, startPoint.value, endPoint.value],\r\n  handleSearchRoutes,\r\n  { deep: true }\r\n);\r\n</script>\r\n\r\n<style scoped>\r\n.container {\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n}\r\n</style>\r\n","import script from \"./CreateCourse.vue?vue&type=script&setup=true&lang=ts\"\nexport * from \"./CreateCourse.vue?vue&type=script&setup=true&lang=ts\"\n\nimport \"./CreateCourse.vue?vue&type=style&index=0&id=3024e6c6&scoped=true&lang=css\"\n\nimport exportComponent from \"../../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-3024e6c6\"]])\n\nexport default __exports__"],"names":["iconMap","course","location","now","start","end","useMap","map","drawInfoArr","resultdrawArr","markers","Tmapv2","window","adjustZoomLevelToFitRoute","length","bounds","LatLngBounds","forEach","point","extend","value","fitBounds","console","error","createPolylineSegment","segmentPath","color","weight","Polyline","path","strokeColor","strokeWeight","fillOpacity","direction","directionColor","clearRoute","line","setVisible","clearMarkers","marker","setMap","drawLine","arrPoint","totalPoints","SEGMENT_WEIGHTS","SEGMENT_COLORS","index","Math","floor","slice","polyline","push","requestLocationPermission","Promise","resolve","reject","navigator","geolocation","getCurrentPosition","position","code","PERMISSION_DENIED","alert","initTmap","Map","width","height","zoom","scaleBar","zoomControl","httpsMode","removeMarker","latitude","longitude","markerIndex","findIndex","getPosition","lat","lng","splice","log","checkDuplMarker","some","addMarker","gubun","markerPosition","LatLng","Marker","icon","searchRoutes","async","startLocation","endLocation","passList","passListString","join","resultData","requestRoute","String","data","geometry","properties","type","coordinates","coord","latlng","Point","convertPoint","Projection","convertEPSG3857ToWGS84GEO","convertChange","_lat","_lng","searchRoutesTest","pointType","includes","latlon","moveLocation","isNaN","currentLocation","setCenter","setZoom","moveNowLocation","coords","defaultLatitude","defaultLongitude","_withScopeId","n","_pushScopeId","_popScopeId","_hoisted_1","class","_hoisted_2","_createElementVNode","id","_defineComponent","__name","setup","__props","createCourseStore","useCreateCourseStore","page","showSearch","startPointValid","endPointValid","wayPointsValid","wayPoint","endPoint","startPoint","storeToRefs","ref","componentMap","WayPoint","InputTitle","SelectKeyword","CheckPublic","CompleteCourse","SuggestionHelper","ResultHelper","onMounted","handleMarkerChange","newPoint","oldPoint","markerType","isDuplicate","name","handleSearchRoutes","watch","newStartPoint","oldStartPoint","deep","newEndPoint","oldEndPoint","newWayPoints","oldWayPoints","i","_ctx","_cache","_openBlock","_createElementBlock","_unref","_createBlock","MapSearch","key","_createCommentVNode","_createVNode","SwipeModal","default","_withCtx","SearchResult","_resolveDynamicComponent","_","__exports__"],"sourceRoot":""}