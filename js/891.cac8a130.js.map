{"version":3,"file":"js/891.cac8a130.js","mappings":"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","sources":["webpack://frontend/./src/utils/iconMap.ts","webpack://frontend/./src/hooks/useMap.ts","webpack://frontend/./src/views/recommendedCourse/CreateCourse.vue?e9bc","webpack://frontend/./src/views/recommendedCourse/CreateCourse.vue","webpack://frontend/./src/views/recommendedCourse/CreateCourse.vue?f9ba"],"sourcesContent":["import course from '@/assets/icon/course.svg';\nimport end from '@/assets/icon/end.svg';\nimport location from '@/assets/icon/location.svg';\nimport now from '@/assets/icon/now.svg';\nimport start from '@/assets/icon/start.svg';\n\nexport type IGubunType = 'start' | 'end' | 'location' | 'course' | 'now';\nexport const iconMap = {\n  course,\n  location,\n  now,\n  start,\n  end,\n};\n","import { requestRoute } from '@/apis/courseFeature';\nimport { iconMap, IGubunType } from '@/utils/iconMap';\nimport { ISpotType } from '@/stores/recommendedCourse/type';\nimport { findNowLocation } from '@/utils/map';\n\nexport const useMap = (map: any) => {\n  let drawInfoArr: any[] = [];\n  let resultdrawArr: any[] = [];\n  let markers: any[] = [];\n\n  const Tmapv2 = (window as any).Tmapv2;\n\n  const adjustZoomLevelToFitRoute = (drawInfoArr: any[]) => {\n    if (drawInfoArr.length > 0) {\n      const bounds = new Tmapv2.LatLngBounds();\n\n      drawInfoArr.forEach((point: any) => {\n        bounds.extend(point);\n      });\n\n      map.value.fitBounds(bounds);\n    } else {\n      console.error('Zoom 조정할 경로 데이터가 부족합니다.');\n    }\n  };\n\n  const createPolylineSegment = (\n    segmentPath: any[],\n    color: string,\n    weight: number\n  ) => {\n    return new Tmapv2.Polyline({\n      path: segmentPath,\n      strokeColor: color,\n      strokeWeight: weight,\n      fillOpacity: 1.0,\n      map: map.value,\n      direction: true,\n      directionColor: 'white',\n    });\n  };\n\n  const clearRoute = () => {\n    if (resultdrawArr.length > 0) {\n      resultdrawArr.forEach((line) => {\n        if (line && typeof line.setVisible === 'function') {\n          line.setVisible(false);\n        }\n      });\n      resultdrawArr = [];\n    }\n  };\n\n  const clearMarkers = () => {\n    markers.forEach((marker) => marker.setMap(null));\n    markers = [];\n  };\n\n  const drawLine = (arrPoint: any[]) => {\n    const totalPoints = arrPoint.length;\n    const SEGMENT_WEIGHTS = 10;\n    const SEGMENT_COLORS = [\n      '#75FFA5',\n      '#22F779',\n      '#13D168',\n      '#07AB56',\n      '#008545',\n    ];\n\n    SEGMENT_COLORS.forEach((color, index) => {\n      const start = Math.floor(totalPoints * (index * 0.2));\n      const end = Math.floor(totalPoints * ((index + 1) * 0.2));\n\n      const segmentPath = arrPoint.slice(start, end + 1);\n      const polyline = createPolylineSegment(\n        segmentPath,\n        color,\n        SEGMENT_WEIGHTS\n      );\n\n      resultdrawArr.push(polyline);\n    });\n\n    adjustZoomLevelToFitRoute(arrPoint);\n  };\n\n  const initTmap = (map: any) => {\n    return new Promise<void>((resolve, reject) => {\n      if (!map.value) {\n        map.value = new Tmapv2.Map('map_div', {\n          width: '100%',\n          height: '100%',\n          zoom: 15,\n          scaleBar: false,\n          zoomControl: false,\n        });\n        resolve();\n      } else {\n        reject('지도 객체 초기화 실패: 이미 초기화된 상태입니다.');\n      }\n    });\n  };\n\n  const removeMarker = (location: ISpotType) => {\n    const { latitude, longitude } = location;\n    if (!map.value || latitude === 0 || longitude === 0) return;\n\n    const markerIndex = markers.findIndex(\n      (marker) =>\n        marker.getPosition().lat() === latitude &&\n        marker.getPosition().lng() === longitude\n    );\n\n    if (markerIndex !== -1) {\n      markers[markerIndex].setMap(null);\n      markers.splice(markerIndex, 1);\n    } else {\n      console.log('해당 위치에 마커가 없습니다.');\n    }\n  };\n\n  const checkDuplMarker = (location: ISpotType): boolean => {\n    const { latitude, longitude } = location;\n    if (!latitude || !longitude || !map.value) return false;\n\n    return markers.some(\n      (marker) =>\n        marker.getPosition().lat() === latitude &&\n        marker.getPosition().lng() === longitude\n    );\n  };\n\n  const addMarker = (location: ISpotType, gubun: IGubunType) => {\n    const { latitude, longitude } = location;\n    if (!map.value || latitude === 0 || longitude === 0) return;\n\n    const markerPosition = new Tmapv2.LatLng(latitude, longitude);\n    const marker = new Tmapv2.Marker({\n      position: markerPosition,\n      icon: iconMap[gubun],\n      map: map.value,\n    });\n\n    markers.push(marker);\n    return marker;\n  };\n\n  const searchRoutes = async (\n    startLocation: ISpotType,\n    endLocation: ISpotType,\n    passList?: ISpotType[]\n  ) => {\n    try {\n      clearRoute();\n\n      const passListString = passList\n        ? passList\n            .map((point) => `${point.longitude},${point.latitude}`)\n            .join('_')\n        : '';\n\n      const resultData = await requestRoute(\n        String(startLocation.longitude),\n        String(startLocation.latitude),\n        String(endLocation.longitude),\n        String(endLocation.latitude),\n        passListString\n      );\n\n      drawInfoArr = [];\n\n      resultData.forEach((data: any) => {\n        const geometry = data.geometry;\n        const properties = data.properties;\n\n        if (geometry.type === 'LineString') {\n          geometry.coordinates.forEach((coord: any) => {\n            const latlng = new Tmapv2.Point(coord[0], coord[1]);\n            const convertPoint =\n              Tmapv2.Projection.convertEPSG3857ToWGS84GEO(latlng);\n            const convertChange = new Tmapv2.LatLng(\n              convertPoint._lat,\n              convertPoint._lng\n            );\n            drawInfoArr.push(convertChange);\n          });\n        }\n      });\n\n      drawLine(drawInfoArr);\n    } catch (error) {\n      console.error('경로 검색 중 오류 발생:', error);\n    }\n  };\n\n  const searchRoutesTest = async (map: any) => {\n    const startLocation: [number, number] = [\n      33.433944015499456, 126.43602130714433,\n    ];\n    const endLocation: [number, number] = [\n      33.45120886113757, 126.48765563964844,\n    ];\n    const passList =\n      '126.39573248492509,33.47190207955216_126.44226001173622,33.47486469122896_126.42766879469521,33.48001928930712';\n\n    try {\n      const resultData = await requestRoute(\n        String(startLocation[1]),\n        String(startLocation[0]),\n        String(endLocation[1]),\n        String(endLocation[0]),\n        passList\n      );\n\n      if (resultdrawArr.length > 0) {\n        resultdrawArr.forEach((line) => line.setMap(null));\n        resultdrawArr = [];\n      }\n\n      drawInfoArr = [];\n\n      resultData.forEach((data: any) => {\n        const geometry = data.geometry;\n        const properties = data.properties;\n\n        if (geometry.type === 'LineString') {\n          geometry.coordinates.forEach((coord: any) => {\n            const latlng = new Tmapv2.Point(coord[0], coord[1]);\n            const convertPoint =\n              Tmapv2.Projection.convertEPSG3857ToWGS84GEO(latlng);\n            const convertChange = new Tmapv2.LatLng(\n              convertPoint._lat,\n              convertPoint._lng\n            );\n            drawInfoArr.push(convertChange);\n          });\n        } else if (\n          properties.pointType !== 'GP' &&\n          properties.pointType.includes('PP')\n        ) {\n          const latlon = new Tmapv2.Point(\n            geometry.coordinates[0],\n            geometry.coordinates[1]\n          );\n          const convertPoint =\n            Tmapv2.Projection.convertEPSG3857ToWGS84GEO(latlon);\n\n          new Tmapv2.Marker({\n            position: new Tmapv2.LatLng(convertPoint._lat, convertPoint._lng),\n            icon: iconMap['location'],\n            map: map.value,\n          });\n        }\n      });\n      drawLine(drawInfoArr);\n    } catch (error) {\n      console.error('경로 검색 중 오류 발생:', error);\n    }\n  };\n\n  const moveLocation = (latitude: number, longitude: number) => {\n    if (!map.value) return;\n\n    if (!isNaN(latitude) && !isNaN(longitude)) {\n      const currentLocation = new Tmapv2.LatLng(latitude, longitude);\n      map.value.setCenter(currentLocation);\n      map.value.setZoom(15);\n    } else {\n      console.error('유효하지 않은 좌표:', latitude, longitude);\n    }\n  };\n\n  const moveNowLocation = async () => {\n    if (!map.value) return;\n\n    let latitude, longitude;\n    try {\n      [latitude, longitude] = await findNowLocation();\n\n      const markerPosition = new Tmapv2.LatLng(latitude, longitude);\n\n      const marker = new Tmapv2.Marker({\n        position: markerPosition,\n        icon: iconMap['now'],\n        map: map.value,\n      });\n    } catch (error) {\n      [latitude, longitude] = [33.50712081595116, 126.49340629577637];\n      console.error('현재 위치를 찾을 수 없습니다:', error);\n    }\n\n    moveLocation(latitude, longitude);\n  };\n\n  return {\n    initTmap,\n    removeMarker,\n    searchRoutes,\n    addMarker,\n    clearMarkers,\n    checkDuplMarker,\n    moveLocation,\n    searchRoutesTest,\n    moveNowLocation,\n  };\n};\n","import { defineComponent as _defineComponent } from 'vue'\nimport { unref as _unref, openBlock as _openBlock, createBlock as _createBlock, createCommentVNode as _createCommentVNode, createElementVNode as _createElementVNode, resolveDynamicComponent as _resolveDynamicComponent, withCtx as _withCtx, createVNode as _createVNode, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\"\n\nconst _withScopeId = (n: any) => (_pushScopeId(\"data-v-9f5b3414\"),n=n(),_popScopeId(),n)\nconst _hoisted_1 = { class: \"container\" }\nconst _hoisted_2 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(\"div\", { id: \"map_div\" }, null, -1))\n\nimport { ref, onMounted, defineComponent, watch } from 'vue';\r\nimport { useMap } from '@/hooks';\r\nimport { SwipeModal } from '@/components';\r\nimport {\r\n  SuggestionHelper,\r\n  ResultHelper,\r\n  WayPoint,\r\n  SelectKeyword,\r\n  CheckPublic,\r\n  CompleteCourse,\r\n  MapSearch,\r\n  SearchResult,\r\n} from './components';\r\n\r\nimport { storeToRefs } from 'pinia';\r\nimport { useCreateCourseStore } from '@/stores/recommendedCourse/createCourse';\r\nimport { ISpotType } from '@/stores/recommendedCourse/type';\r\n\r\n\nexport default /*#__PURE__*/_defineComponent({\n  __name: 'CreateCourse',\n  setup(__props) {\n\r\nconst createCourseStore = useCreateCourseStore();\r\nconst {\r\n  page,\r\n  showSearch,\r\n  startPointValid,\r\n  endPointValid,\r\n  wayPointsValid,\r\n  wayPoint,\r\n  endPoint,\r\n  startPoint,\r\n} = storeToRefs(createCourseStore);\r\n\r\nconst map = ref<any>(null);\r\nconst {\r\n  initTmap,\r\n  addMarker,\r\n  searchRoutes,\r\n  removeMarker,\r\n  checkDuplMarker,\r\n  moveNowLocation,\r\n} = useMap(map);\r\n\r\nconst componentMap: { [key: number]: ReturnType<typeof defineComponent> } = {\r\n  1: WayPoint,\r\n  2: SelectKeyword,\r\n  3: CheckPublic,\r\n  4: CompleteCourse,\r\n  11: SuggestionHelper,\r\n  12: ResultHelper,\r\n};\r\n\r\nonMounted(async () => {\r\n  await initTmap(map);\r\n  await moveNowLocation();\r\n});\r\n\r\nconst handleMarkerChange = (\r\n  newPoint: ISpotType,\r\n  oldPoint: ISpotType | undefined,\r\n  markerType: 'start' | 'end' | 'location'\r\n) => {\r\n  if (newPoint && startPointValid.value) {\r\n    const isDuplicate = checkDuplMarker(newPoint);\r\n\r\n    if (!isDuplicate) {\r\n      addMarker(newPoint, markerType);\r\n    }\r\n  }\r\n\r\n  if (\r\n    oldPoint &&\r\n    (newPoint.name !== oldPoint.name ||\r\n      newPoint.longitude !== oldPoint.longitude ||\r\n      newPoint.latitude !== oldPoint.latitude)\r\n  ) {\r\n    removeMarker(oldPoint);\r\n  }\r\n};\r\n\r\nconst handleSearchRoutes = () => {\r\n  if (startPointValid.value && endPointValid.value && wayPointsValid.value) {\r\n    searchRoutes(startPoint.value, endPoint.value, wayPoint.value);\r\n  }\r\n};\r\n\r\nwatch(\r\n  () => startPoint.value,\r\n  (newStartPoint, oldStartPoint) => {\r\n    handleMarkerChange(newStartPoint, oldStartPoint, 'start');\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => endPoint.value,\r\n  (newEndPoint, oldEndPoint) => {\r\n    handleMarkerChange(newEndPoint, oldEndPoint, 'end');\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => [...wayPoint.value],\r\n  (newWayPoints, oldWayPoints) => {\r\n    newWayPoints.forEach((newPoint, index) => {\r\n      const oldPoint = oldWayPoints[index];\r\n      handleMarkerChange(newPoint, oldPoint, 'location');\r\n    });\r\n\r\n    if (newWayPoints.length < oldWayPoints.length) {\r\n      for (let i = newWayPoints.length; i < oldWayPoints.length; i++) {\r\n        removeMarker(oldWayPoints[i]);\r\n      }\r\n    }\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => [wayPoint.value, startPoint.value, endPoint.value],\r\n  handleSearchRoutes,\r\n  { deep: true }\r\n);\r\n\nreturn (_ctx: any,_cache: any) => {\n  return (_openBlock(), _createElementBlock(\"div\", _hoisted_1, [\n    (_unref(showSearch))\n      ? (_openBlock(), _createBlock(_unref(MapSearch), { key: 0 }))\n      : _createCommentVNode(\"\", true),\n    _hoisted_2,\n    _createVNode(_unref(SwipeModal), null, {\n      default: _withCtx(() => [\n        (_unref(showSearch))\n          ? (_openBlock(), _createBlock(_unref(SearchResult), { key: 0 }))\n          : (componentMap[_unref(page)])\n            ? (_openBlock(), _createBlock(_resolveDynamicComponent(componentMap[_unref(page)]), { key: 1 }))\n            : _createCommentVNode(\"\", true)\n      ]),\n      _: 1\n    })\n  ]))\n}\n}\n\n})","<template>\r\n  <div class=\"container\">\r\n    <MapSearch v-if=\"showSearch\" />\r\n    <div id=\"map_div\"></div>\r\n    <SwipeModal>\r\n      <SearchResult v-if=\"showSearch\" />\r\n      <component\r\n        v-else-if=\"componentMap[page]\"\r\n        :is=\"componentMap[page]\"\r\n      />\r\n    </SwipeModal>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { ref, onMounted, defineComponent, watch } from 'vue';\r\nimport { useMap } from '@/hooks';\r\nimport { SwipeModal } from '@/components';\r\nimport {\r\n  SuggestionHelper,\r\n  ResultHelper,\r\n  WayPoint,\r\n  SelectKeyword,\r\n  CheckPublic,\r\n  CompleteCourse,\r\n  MapSearch,\r\n  SearchResult,\r\n} from './components';\r\n\r\nimport { storeToRefs } from 'pinia';\r\nimport { useCreateCourseStore } from '@/stores/recommendedCourse/createCourse';\r\nimport { ISpotType } from '@/stores/recommendedCourse/type';\r\n\r\nconst createCourseStore = useCreateCourseStore();\r\nconst {\r\n  page,\r\n  showSearch,\r\n  startPointValid,\r\n  endPointValid,\r\n  wayPointsValid,\r\n  wayPoint,\r\n  endPoint,\r\n  startPoint,\r\n} = storeToRefs(createCourseStore);\r\n\r\nconst map = ref<any>(null);\r\nconst {\r\n  initTmap,\r\n  addMarker,\r\n  searchRoutes,\r\n  removeMarker,\r\n  checkDuplMarker,\r\n  moveNowLocation,\r\n} = useMap(map);\r\n\r\nconst componentMap: { [key: number]: ReturnType<typeof defineComponent> } = {\r\n  1: WayPoint,\r\n  2: SelectKeyword,\r\n  3: CheckPublic,\r\n  4: CompleteCourse,\r\n  11: SuggestionHelper,\r\n  12: ResultHelper,\r\n};\r\n\r\nonMounted(async () => {\r\n  await initTmap(map);\r\n  await moveNowLocation();\r\n});\r\n\r\nconst handleMarkerChange = (\r\n  newPoint: ISpotType,\r\n  oldPoint: ISpotType | undefined,\r\n  markerType: 'start' | 'end' | 'location'\r\n) => {\r\n  if (newPoint && startPointValid.value) {\r\n    const isDuplicate = checkDuplMarker(newPoint);\r\n\r\n    if (!isDuplicate) {\r\n      addMarker(newPoint, markerType);\r\n    }\r\n  }\r\n\r\n  if (\r\n    oldPoint &&\r\n    (newPoint.name !== oldPoint.name ||\r\n      newPoint.longitude !== oldPoint.longitude ||\r\n      newPoint.latitude !== oldPoint.latitude)\r\n  ) {\r\n    removeMarker(oldPoint);\r\n  }\r\n};\r\n\r\nconst handleSearchRoutes = () => {\r\n  if (startPointValid.value && endPointValid.value && wayPointsValid.value) {\r\n    searchRoutes(startPoint.value, endPoint.value, wayPoint.value);\r\n  }\r\n};\r\n\r\nwatch(\r\n  () => startPoint.value,\r\n  (newStartPoint, oldStartPoint) => {\r\n    handleMarkerChange(newStartPoint, oldStartPoint, 'start');\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => endPoint.value,\r\n  (newEndPoint, oldEndPoint) => {\r\n    handleMarkerChange(newEndPoint, oldEndPoint, 'end');\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => [...wayPoint.value],\r\n  (newWayPoints, oldWayPoints) => {\r\n    newWayPoints.forEach((newPoint, index) => {\r\n      const oldPoint = oldWayPoints[index];\r\n      handleMarkerChange(newPoint, oldPoint, 'location');\r\n    });\r\n\r\n    if (newWayPoints.length < oldWayPoints.length) {\r\n      for (let i = newWayPoints.length; i < oldWayPoints.length; i++) {\r\n        removeMarker(oldWayPoints[i]);\r\n      }\r\n    }\r\n  },\r\n  { deep: true }\r\n);\r\n\r\nwatch(\r\n  () => [wayPoint.value, startPoint.value, endPoint.value],\r\n  handleSearchRoutes,\r\n  { deep: true }\r\n);\r\n</script>\r\n\r\n<style scoped>\r\n.container {\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n}\r\n</style>\r\n","import script from \"./CreateCourse.vue?vue&type=script&setup=true&lang=ts\"\nexport * from \"./CreateCourse.vue?vue&type=script&setup=true&lang=ts\"\n\nimport \"./CreateCourse.vue?vue&type=style&index=0&id=9f5b3414&scoped=true&lang=css\"\n\nimport exportComponent from \"../../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-9f5b3414\"]])\n\nexport default __exports__"],"names":["iconMap","course","location","now","start","end","useMap","map","drawInfoArr","resultdrawArr","markers","Tmapv2","window","adjustZoomLevelToFitRoute","length","bounds","LatLngBounds","forEach","point","extend","value","fitBounds","console","error","createPolylineSegment","segmentPath","color","weight","Polyline","path","strokeColor","strokeWeight","fillOpacity","direction","directionColor","clearRoute","line","setVisible","clearMarkers","marker","setMap","drawLine","arrPoint","totalPoints","SEGMENT_WEIGHTS","SEGMENT_COLORS","index","Math","floor","slice","polyline","push","initTmap","Promise","resolve","reject","Map","width","height","zoom","scaleBar","zoomControl","removeMarker","latitude","longitude","markerIndex","findIndex","getPosition","lat","lng","splice","log","checkDuplMarker","some","addMarker","gubun","markerPosition","LatLng","Marker","position","icon","searchRoutes","async","startLocation","endLocation","passList","passListString","join","resultData","requestRoute","String","data","geometry","properties","type","coordinates","coord","latlng","Point","convertPoint","Projection","convertEPSG3857ToWGS84GEO","convertChange","_lat","_lng","searchRoutesTest","pointType","includes","latlon","moveLocation","isNaN","currentLocation","setCenter","setZoom","moveNowLocation","findNowLocation","_withScopeId","n","_pushScopeId","_popScopeId","_hoisted_1","class","_hoisted_2","_createElementVNode","id","_defineComponent","__name","setup","__props","createCourseStore","useCreateCourseStore","page","showSearch","startPointValid","endPointValid","wayPointsValid","wayPoint","endPoint","startPoint","storeToRefs","ref","componentMap","WayPoint","SelectKeyword","CheckPublic","CompleteCourse","SuggestionHelper","ResultHelper","onMounted","handleMarkerChange","newPoint","oldPoint","markerType","isDuplicate","name","handleSearchRoutes","watch","newStartPoint","oldStartPoint","deep","newEndPoint","oldEndPoint","newWayPoints","oldWayPoints","i","_ctx","_cache","_openBlock","_createElementBlock","_unref","_createBlock","MapSearch","key","_createCommentVNode","_createVNode","SwipeModal","default","_withCtx","SearchResult","_resolveDynamicComponent","_","__exports__"],"sourceRoot":""}